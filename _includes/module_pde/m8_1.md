# Transportligninger

I innføringen kalte vi ligningen

$$
u_x = u_y
$$

for en transportligning. La oss tenke oss at en av variablene er tid. En mer generell versjon av samme ligning er

$$
u_t + a u_x = 0
$$

for et tall $a$. Dette er ligningen som vi skal studere nå. Senere vil vi se på den enda mer generelle ligningen

$$
u_t + a(x,t,u)u_x = g(x,t),
$$

og den nært beslektede *bevaringsloven*

$$
u_t + f(x,t,u)_x = g(x,t)
$$

## 1. En analytisk løsning

### Oppgave 

Sjekk med derivasjon at $u(x,t) = g(x-at)$ løser ligningen 
$$
u_t + a u_x = 0
$$
for hvilken som helst envariabelfunksjon $g$.

### a) Med initalbetingelser

Anta at vi har en initialbetingelse av formen $u(x,0) = f(x)$.

Sammenlign det med løsningen $u(x,t) = g(x-at)$; vi setter inn $t=0$ og får $u(x,0)=g(x)$. Dvs. vi må sette $f=g$ for at initialbetingelsen skal være tilfredsstilt. Løsningen er altså

$$
u(x,t) = f(x-at)
$$

Hva betyr det? Vi ser at løsningen flytter på seg, med hastighet (inkludert retning) bestemt av $a$. Prøv koden under. Prøv også å endre på
funksjonen 'f(x)' og hastigheten 'a'.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# dette er funksjonen vi skal bruke
# du kan erstatte med en annen funksjon om du vil
def f(x):
    return np.sin(x)

# vi lager verdiene av x og t
x = np.arange(0, 2*np.pi, 0.01)
t = np.arange(0, 2*np.pi, 0.05)

# vi lager rutenettet
X, T = np.meshgrid(x, t)

# vi regner ut funksjonen på rutenettet
a = 1   # hastighet
u = f(X - a*T)

# vi plotter løsningen for tid t = 0
fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(x, u[0, :])
ax.set_xlabel("x")
ax.set_ylabel("u(x, 0)")
ax.set_title("Startprofil ved t = 0")

plt.show()
```


```{pyodide-python}
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

plt.close("all")

# vi lager én figur for animasjonen
fig, ax = plt.subplots(figsize=(6, 4))

# vi setter faste aksegrenser
ax.set_xlim(x[0], x[-1])
ax.set_ylim(-1.1, 1.1)
ax.set_xlabel("x")
ax.set_ylabel("u(x,t)")
ax.set_title("Transport av startprofil")

# rød kurve: startprofil f(x)
ax.plot(x, f(x), color="red", linestyle="--", label="f(x) (startprofil)")

# blå kurve: initialplott av løsningen for tid t = 0
line, = ax.plot(x, u[0, :], color="blue", label="u(x,t)")

ax.legend()

# oppdater plottet for andre tider t_i
def animate(i):
    line.set_ydata(u[i, :])
    return line,

# animasjon
# interval bestemmer hvor fort det vises
# frames angir hvor mange tider t_i som inngår
ani = animation.FuncAnimation(
    fig,
    animate,
    frames=t.size,
    interval=20,
    blit=True
)

# vi viser animasjonen i Quarto / nettleser
HTML(ani.to_jshtml())
plt.show()
```

Det er også nyttig å se på nivåkurveplot av funksjonen $u(x,t)$ (også kalt kontourplott). Nivåkurvene har et spesielt navn i denne sammenhengen: **karakteristikker**. 

Siden vi kjenner verdien av løsningen fra initialbetingelsene, så vet vi hvor nivåkurvene skjærer $x$-aksen. Da kan vi finne løsningen for alle tidspunkt ved å gå langs karakteristikkene.


```{pyodide-python}
import matplotlib.pyplot as plt

plt.close("all")

# konturplott av løsningen u(x,t)
fig, ax = plt.subplots(figsize=(6, 4))

cont = ax.contour(X, T, u, levels=20)
ax.set_xlabel("x")
ax.set_ylabel("t")

# fargeskala
fig.colorbar(cont, ax=ax)

plt.show()
```

### b) Med randbetingelser

Et typisk randverdiproblem er:

$$
u_t + a u_x = 0, \quad 0<x<1, \quad u(x,0)=f(x), \quad  u(0,t)=h(t)
$$

Løsningen er fortsatt $u(x,t) = g(x-at)$, men ved å sette $x=0$ får vi $u(0,t) = g(-at)$, slik at $g(-at) = h(t)$. Dermed ser vi at $g(x-at) = g(-at)$ slik at $t$ må tilfredsstille $t = -\frac{x-at}{a}$ og vi får

**Alternativ 1**

$$
u(x,t) = h\left( -\frac{x-at}{a}\right).
$$

Men hva med den gamle løsningen

**Alternativ 2**
$$
u(x,t) = f(x-at)?
$$

Vi kan forstå svaret bedre med å se på konturene. Det viser seg at løsningen $u(x,t)$ er en av de to alternativene over, avhengig av verdien til $x, t$. 


### Oppgave

Prøv å forstå fra plotten under at alternativ 1 inntreffer om $x < at$, mens om $x > at$ får vi alternativ 2.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# nytt rutenett
x = np.arange(0, 1, 0.01)
t = np.arange(0, 1, 0.01)
X, T = np.meshgrid(x, t)

# parametre
a = 1  # hastighet

# rand-/startfunksjoner
def h(x):
    return 2 + np.sin(x)

# løsningen u(x,t)
def u(x, t):
    return np.where(x > a*t, f(x - a*t), h(-(x - a*t)/a))

# vi beregner løsningen på rutenettet
V = u(X, T)

# hvilke verdier vi ønsker å se nivåkurver for
levels = np.linspace(-1, 3, 40)

# konturplott
fig, ax = plt.subplots(figsize=(6, 4))
cont = ax.contour(X, T, V, levels=levels)

ax.set_xlabel("x")
ax.set_ylabel("t")

fig.colorbar(cont, ax=ax)

plt.show()
```

## 2. Lax-Friedrichs metode

Vår 'fasit' på hva løsningen på $u$ for denne partielle differensialligningen blir metoden:

$$
u^{i+1}_j = \frac{1}{2}(u^i_{j+1} + u^i_{j-1}) + \frac{ak}{2h} u^i_{j-1} - \frac{ak}{2h} u^i_{j+1}
$$

som heter **Lax-Friedrichs metode**. Det er ikke nødvendigvis den mest nøyaktige metoden, men den er pålitelig, lite krevende å implementere, og kan lett tilpasses til mer generelle bevaringslover (se senere).

Formelen leses slik: $u^i_j$ er verdien til funksjonen ved tidssteg nummer $i$ og $x$-posisjon nummer $j$, dvs. $u_j^i = u(x_j,t_i)$. Når vi begynner så kjenner vi alle funksjonsverdiene ved starttiden, dvs. $u^0_j$ for alle $j$. Formelen forteller oss derfor hvordan vi finner alle funksjonsverdiene ett tidsteg frem i tid. 

I tillegg kommer randbetingelsene, som ikke er tatt med i formelen. 

De følgende kodecellene må kjøres etter hverandre.

I den første kodecellen definerer vi Lax–Friedrichs-metoden, som er et numerisk skjema for å løse transportlikningen. Funksjonen tar inn løsningen ved et gitt tidspunkt og beregner løsningen ett tidssteg videre ved å bruke verdier i nabopunktene i rom, samt gitte randbetingelser.

I den neste kodecellen setter vi opp selve problemet som skal løses. Her definerer vi randbetingelsene på venstre og høyre side, lager et rutenett i rom og tid, og angir initialbetingelsen. Deretter bruker vi Lax–Friedrichs-metoden til å beregne løsningen steg for steg fremover i tid.

I den siste kodecellen visualiserer vi den numeriske løsningen. Vi lager en animasjon som viser hvordan løsningen $u(x,t)$  utvikler seg over tid, slik at vi kan se hvordan startprofilen transporteres gjennom rommet. 


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# Funksjon som gjennomfører ett tidssteg med Lax–Friedrichs-metoden
#
# a  : hastighet fra transportlikningen
# fa : randbetingelse på venstre side (funksjon av tid)
# fb : randbetingelse på høyre side (funksjon av tid)
# ui : funksjonsverdier ved nåværende tidspunkt
# h  : steglengde i rom
# k  : steglengde i tid
# t  : nåværende tid
#
# returnerer:
# unext : funksjonsverdier ved neste tidspunkt
def laxfrid(a, fa, fb, ui, h, k, t):
    n = ui.size
    unext = np.zeros(n)

    # indre punkter
    for j in range(1, n-1):
        unext[j] = (
            0.5 * (ui[j+1] + ui[j-1])
            - (a * k / (2 * h)) * (ui[j+1] - ui[j-1])
        )

    # randbetingelser
    unext[0]  = fa(t)
    unext[-1] = fb(t)

    return unext
```


```{pyodide-python}
import numpy as np

# randbetingelse på venstre side
def fa(t):
    return np.sin(np.pi * t)

# randbetingelse på høyre side
def fb(t):
    return 0.0

# parametre
hastighet = 1

# vi setter opp rutenettet
T = 1
n = 200          # antall tidspunkter
a = -1
b = 1
m = 50           # antall rompunkter

# verdier for tid og rom
t = np.linspace(0, T, n)
x = np.linspace(a, b, m)

# steglengder
k = t[1] - t[0]
h = x[1] - x[0]

# initialiserer løsningen
u = np.zeros((n, m))

# initialbetingelse
u[0, :] = np.sin(np.pi * x)

# vi kjører Lax–Friedrichs-metoden i tid
for i in range(1, n):
    u[i, :] = laxfrid(hastighet, fa, fb, u[i-1, :], h, k, t[i])
```


```{pyodide-python}
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

plt.close("all")

# vi lager én figur for animasjonen
fig, ax = plt.subplots(figsize=(6, 4))

# faste aksegrenser
ax.set_xlim(x[0], x[-1])
ax.set_ylim(np.min(u), np.max(u))
ax.set_xlabel("x")
ax.set_ylabel("u(x,t)")
ax.set_title("Numerisk løsning med Lax–Friedrichs-metoden")

# initialplott, for tid t = 0
line, = ax.plot(x, u[0, :], color="blue")

# oppdater plottet for senere tider t_i
def animate(i):
    line.set_ydata(u[i, :])
    return line,

# animasjon
# interval bestemmer hvor fort det vises
# frames angir hvor mange tider t_i som inngår
ani = animation.FuncAnimation(
    fig,
    animate,
    frames=t.size,
    interval=100,   # roligere tempo for undervisning
    blit=True
)

# vi viser animasjonen i Quarto / nettleser
HTML(ani.to_jshtml())
plt.show()
```
