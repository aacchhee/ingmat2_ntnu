# Bevaringslover

## 1. Bevaringslover

Vi har kalt en ligning på formen

$$
\frac{\partial u}{\partial t} + \frac{\partial}{\partial x}f\big(u(x,t),x,t \big) = 0
$$

for en **bevaringslov** med **fluks** $f$. Hvorfor?

**Fluks** i et punkt $(x,t)$ er definert som mengden av $u$ som flyter forbi $x$ per tidenhet.

Hvis ligningen beskriver transport av et stoff $u$ med hastighet $v$, er fluksen lik $f(u,x,t) = u\cdot v(u,x,t)$.

Fluks er ofte en funksjon av $u$ alene, for eksempel transport av et stoff med konstant hastighet $a$ følger $f(u,x,t) = f(u) = a u$, slik vi har allerede sett.

### Mer om fluks

*kommer seinere*

### a) Ficks lover og diffusjon

Ficks lover beskriver hvordan **diffusjon** av et stoff fungerer. 

Den første loven er at fluksen som skyldes diffusjon tar formen

$$
f(u) = -D \frac{\partial u}{\partial x}
$$

hvor $D$ er **diffusjonskoeffisient**. 

Den andre loven er det vi får når vi setter den første loven inn i bevaringsloven over, altså

$$
\frac{\partial u}{\partial t} - \frac{\partial}{\partial x} \left( D\frac{\partial u}{\partial x}\right)= 0
$$

Legg merke til at vi får **varmeligningen** hvis $D$ er konstant! Varmeligningen beskriver altså diffusjon av varme.

### b) Konveksjon-diffusjon

Det er imidlertidig ikke uvanlig at fluksen skyldes en kombinasjon av flere faktorer, f eks hvis stoffet transporteres av en hastighet $v(u)$, men samtidig utsettes for diffusjon med koeffisient $D$, får vi en ligning

$$
\frac{\partial u}{\partial t} + \frac{\partial}{\partial x}\big( u v(u) \big) - \frac{\partial}{\partial x} \left( D\frac{\partial u}{\partial x}\right)= 0
$$

En sånn ligning kalles for en konveksjon-diffusjon. Oppførselen kombinerer egenskaper av både transportligninger og diffusjoner, hvor den relative størrelsen av $v$ og $D$ vil typisk bestemme hvilken som dominerer.

Hvis konsentrasjon endres i tillegg (f.eks. ved en kjemisk reaksjon), vil vi få ett ledd $f(u)$ på høyresiden og ligningen kalles en **reaksjon-konveksjon-diffusjon**!

### c) Flere dimensjoner og divergens

La oss ta en kort titt på funksjoner $u(x,y,t)$. 

Fluksen blir nå et vektorfelt $\vec{f}=(I,J)$, hvor $I$ beskriver hvor mye stoff flyter i $x$-retning over en lengdeenhet plassert i $y$-retning, og $J$ beskriver hvor mye stoff flyter i $y$-retning over en lengdeenhet plassert i $x$-retning

**Oppgave**: prøv å forklare hvorfor den resulterende bevaringsloven blir

$$
\frac{\partial u}{\partial t} + \frac{\partial I}{\partial x} + \frac{\partial J}{\partial y} = 0
$$

Generelt definerer vi **divergensen** av et vektor felt $\vec{f}=(f_1(\vec{x}), f_2(\vec{x}), \ldots)$  til å være

$$
\nabla \cdot \vec{f} = \frac{\partial f_1}{\partial x_1} + \frac{\partial f_2}{\partial x_2} + \ldots
$$

En bevaringslov i $n$-dimensjoner tar formen

$$
\frac{\partial u}{\partial t} + \nabla \cdot \vec{f}(u) = 0.
$$

## 2. Lax-Friedrichs metode og bevaringslover

Vi vender nå blikket mot bevaringslover, 

$$
u_t + \big( f(u) \big)_x = 0
$$

Det er mulig å finne på en metode som tilsvarer upwind metoden (den heter Godunov metoden), men det krever at vi løser karakteristiske ligninger for å vite hvilken retning er "upwind" til enhvert tid og sted. Derfor er den letteste metoden som fungerer Lax-Friedrichs metoden, med oppdatering:

$$
u^{i+1}_j = \frac{1}{2}(u^u_{j+1} + u^n_{j-1}) - \frac{k}{2h}\big(f(u^i_{j+1})-f(u^i_{j-1})\big)
$$

Indeksen $i$ beskriver tid og $j$ posisjon i rom. Som i tilfellet vi allerede har sett på så gir denne formelen oppdatering av funksjonen et tidssteg om gangen. I tillegg så kommer randbetingelsene på høyre og venstre side av definisjonsområdet.

### Oppgave:

Sjekk at metoden oppgitt under samme navn for ligningen med konstant hastighet er et spesieltilfelle hvor $f(u)=au$.

### Eksempel: Burgers ligning

Mange modeller er gitt ved ligningen

$$
u_t + f(u)_x = 0
$$

Enkleste eksempel er Burgers ligning
$$
u_t + u u_x = \epsilon u_{xx},
$$

hvor $\epsilon\rightarrow 0$. De er like hvis $f(u) = \frac{1}{2}u^2$, men hvor har $\epsilon$ kommet fra? Den er tatt ut av luften, men spiller en viktig rolle. Det kalles for **viskositet** analogt med tilsvarende begrep fra fluidmekanikk. 

Vi viser under forskjellige typer oppførsel for Lax-Friedrichs metode, hvor $\epsilon=0$.





```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

# ------------------------------------------------------------
# Oppsett for figurer (nyttig i notater for å unngå "gamle" plott)
# ------------------------------------------------------------
plt.close("all")
plt.figure(figsize=(6, 4))

# ------------------------------------------------------------
# Fluks for Burgers' ligning: u_t + (f(u))_x = 0, der f(u) = u^2/2
# ------------------------------------------------------------
def flux_burgers(u):
    """Fluksen f(u) for Burgers' ligning."""
    return 0.5 * u**2


# ------------------------------------------------------------
# Lax–Friedrichs-metoden (1D, eksplisitt)
# ------------------------------------------------------------
# fluks: funksjon f(u)
# u: array med løsningen ved tid t (på romgitteret)
# dx: steglengde i rom
# dt: steglengde i tid
# t: nåværende tid (brukes av randbetingelsene)
# u_left(t): randverdi på venstre kant (x = a)
# u_right(t): randverdi på høyre kant (x = b)
def lax_friedrichs_step(fluks, u, dx, dt, t, u_left, u_right):
    """Utfører ett tidssteg med Lax–Friedrichs."""
    n = u.size
    u_next = np.zeros_like(u)

    # Indre punkter (i = 1, ..., n-2)
    # Formelen:
    # u_i^{n+1} = 1/2 (u_{i-1}^n + u_{i+1}^n) - (dt/(2dx)) (f(u_{i+1}^n) - f(u_{i-1}^n))
    for i in range(1, n - 1):
        u_next[i] = 0.5 * (u[i - 1] + u[i + 1]) - (dt / (2 * dx)) * (
            fluks(u[i + 1]) - fluks(u[i - 1])
        )

    # Randbetingelser (Dirichlet)
    u_next[0] = u_left(t)     # venstre rand
    u_next[-1] = u_right(t)   # høyre rand

    return u_next


# ------------------------------------------------------------
# Gitter i tid og rom
# ------------------------------------------------------------
T = 1.0          # sluttid
nt = 200         # antall tidspunkter
a, b = -1.0, 1.0 # romintervall
nx = 100         # antall rompunkter

t_grid = np.linspace(0.0, T, nt)
x_grid = np.linspace(a, b, nx)

dt = t_grid[1] - t_grid[0]
dx = x_grid[1] - x_grid[0]

# ------------------------------------------------------------
# (Midleridig) testplot: viser romgitteret
# ------------------------------------------------------------
plt.plot(x_grid, np.zeros_like(x_grid))
plt.title("Romgitter (x-punkter)")
plt.xlabel("x")
plt.yticks([])
plt.show()
```

### a) En sjokk oppstår

La oss begynne med en fin, glatt initialverdi, som $u(x,0) = \exp(-x^2)$. Vi kommer til å møte et problem, siden toppen av bølgen ved $x=0$ beveger seg til høyre mye fortere enn den delen av kurven som ligger foran. Se video:


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

plt.close("all")

# ------------------------------------------------------------
# Vindu 2: Sett initialbetingelse, løs med Lax–Friedrichs, og animer
# Forutsetter at vindu 1 allerede er kjørt (x_grid, t_grid, dx, dt, osv.)
# ------------------------------------------------------------

# Randbetingelser (Dirichlet)
def u_left(t):
    """Venstre randverdi u(a,t)."""
    return 0.0

def u_right(t):
    """Høyre randverdi u(b,t)."""
    return 0.0

# Initialbetingelse u(x,0)
u0 = np.exp(-(x_grid**2))

# CFL-sjekk (pedagogisk)
cfl = (dt / dx) * np.max(np.abs(u0))
print("max|u0| =", np.max(np.abs(u0)))
print("CFL ~ (dt/dx)*max|u0| =", cfl)

# Lagrer løsningen for alle tider (greit for animasjon)
u = np.zeros((t_grid.size, x_grid.size))
u[0, :] = u0

# Tidsløkken
for n_step in range(1, t_grid.size):
    t_now = t_grid[n_step - 1]
    u[n_step, :] = lax_friedrichs_step(
        flux_burgers, u[n_step - 1, :], dx, dt, t_now, u_left, u_right
    )

# Diagnose: sjekk at løsningen faktisk endrer seg
print("Maks endring fra t0 til t1:", np.max(np.abs(u[1, :] - u[0, :])))

# ------------------------------------------------------------
# Animasjon
# ------------------------------------------------------------
fig, ax = plt.subplots(figsize=(6, 4))

# Faste aksegrenser (som i eksempelet)
ax.set_xlim(x_grid[0], x_grid[-1])
ax.set_ylim(np.min(u), np.max(u))

ax.set_xlabel("x")
ax.set_ylabel("u(x,t)")
ax.set_title("Numerisk løsning med Lax–Friedrichs-metoden")

# Rød stiplet: startprofil
ax.plot(x_grid, u0, color="red", linestyle="--", label="u(x,0) (startprofil)")

# Blå kurve: løsningen som oppdateres
line, = ax.plot(x_grid, u[0, :], color="blue", label="u(x,t)")

ax.legend()

def animate(i):
    line.set_ydata(u[i, :])
    return line,

ani = animation.FuncAnimation(
    fig,
    animate,
    frames=t_grid.size,
    interval=20,
    blit=True
)

HTML(ani.to_jshtml())
plt.show()
```

Den eksakte løsningen utvikler en hopp, som vi kaller for en **sjokk**. Den er assosiert med fenomenet av at karakteristikker krysser hverandre.

Men hva er egentlig den eksakte løsningen? La oss se på nytt på de to eksemplene fra 5_2, hvor vi har tegnet karakteristikkene. Vi tok initialverdiene

**Sjokk**
$$
g(x) = \left\{
\begin{array}{c}
0 \quad & x\leq 0 \\
-1 \quad & x>0
\end{array}
\right.
$$

og 

**Fortynningsbølge**
$$
g(x) = \left\{
\begin{array}{c}
-1 \quad & x\leq 0 \\
0 \quad & x>0
\end{array}
\right.
$$

### b) En sjokk i fart

Vi løser den første situasjon med Lax-Friedrichs metode.

Sofistikerte analytiske metoder sier at løsning skal være at hoppet flytter til høyre med konstant hastighet. Det er imidlertidig ikke noe som man får ut av ligningen alene, man må legge til ekstra fysiske antagelser, typisk i form av såkalte *entropibetingelser*. 

Heldigvis ser det ut som at vår metode har gitt noe rimelig.

Legg merke til at den numeriske metoden ikke gir et rent hopp, men heller en glatt overgang. Det tilsvarer oppførselen til den eksakte løsningen av ligningen

$$
u_x + u u_x = \epsilon u_{xx},
$$

for en liten, men ikke null $\epsilon$ (vi kaller det for numerisk viskositet). Det forklarer hvorfor vi sa $\epsilon\rightarrow 0$ og ikke $\epsilon = 0$ i innledningen. Den grenseverdien kan brukes som et alternativ til entropibetingelser for å definere hva løsningen skal være under sjokk. Det finnes mye litteratur om slike *viskositetsløsninger*.

**Den gode nyheten**: entropiløsninger og viskositetsløsninger er vanskelige å håndtere, men den gode nyheten er at vi kan stort sett kan stole på at den numeriske metoden gir oss det vi er ute etter.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

plt.close("all")

# ------------------------------------------------------------
# Fortsettelse: nytt eksempel med "Riemann-data" (trinnprofil)
# Vi bruker variablene fra vindu 1: x_grid, t_grid, dx, dt
# samt funksjonene flux_burgers og lax_friedrichs_step.
# ------------------------------------------------------------

# Randbetingelser (Dirichlet)
def u_left(t):
    """Venstre randverdi u(a,t)."""
    return 0.0

def u_right(t):
    """Høyre randverdi u(b,t)."""
    return -1.0


# ------------------------------------------------------------
# Initialbetingelse: trinnprofil
# u(x,0) = -1 + 0.5*(1 - sign(x))
#
# Merk:
#  - for x < 0: sign(x) = -1  => u = -1 + 0.5*(1 - (-1)) = 0
#  - for x > 0: sign(x) =  1  => u = -1 + 0.5*(1 - 1)   = -1
# Altså: u = 0 til venstre, og u = -1 til høyre.
# ------------------------------------------------------------
u0 = -1.0 + 0.5 * (1.0 - np.sign(x_grid))

# Lagrer løsningen for alle tider (praktisk for animasjon)
u = np.zeros((t_grid.size, x_grid.size))
u[0, :] = u0

# CFL-sjekk 
cfl = (dt / dx) * np.max(np.abs(u0))
print("max|u0| =", np.max(np.abs(u0)))
print("CFL ~ (dt/dx)*max|u0| =", cfl)

# Tidsløkken (Lax–Friedrichs)
for n_step in range(1, t_grid.size):
    t_now = t_grid[n_step - 1]
    u[n_step, :] = lax_friedrichs_step(
        flux_burgers, u[n_step - 1, :], dx, dt, t_now, u_left, u_right
    )

# Diagnose: sjekk at løsningen endrer seg
print("Maks endring fra t0 til t1:", np.max(np.abs(u[1, :] - u[0, :])))

# ------------------------------------------------------------
# Animasjon 
# ------------------------------------------------------------
fig, ax = plt.subplots(figsize=(6, 4))

ax.set_xlim(x_grid[0], x_grid[-1])
ax.set_ylim(np.min(u), np.max(u))
ax.set_xlabel("x")
ax.set_ylabel("u(x,t)")
ax.set_title("Burgers' ligning: trinnprofil + Lax–Friedrichs")

# Rød stiplet: startprofil
ax.plot(x_grid, u0, color="red", linestyle="--", label="u(x,0) (startprofil)")

# Blå kurve: løsning som oppdateres
line, = ax.plot(x_grid, u[0, :], color="blue", label="u(x,t)")

ax.legend()

def animate(i):
    line.set_ydata(u[i, :])
    return line,

ani = animation.FuncAnimation(
    fig,
    animate,
    frames=t_grid.size,
    interval=20,
    blit=True
)

HTML(ani.to_jshtml())
plt.show()
```

### c) Fortynningsbølge

En annen viktig type oppførsel skjer når karaktarestikkene går fra hverandre. Vi kan se det ved å la $u(x,0)$ være negativ for $u<0$ og positiv for $u>0$. Det er en fortynningsbølge eller ekspansjon.

Det samme kommentar gjelder som med sjokk: også her kan vi stole på at de numeriske løsningene er de vi ønsker oss.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

plt.close("all")

# ------------------------------------------------------------
# Fortsettelse: motsatt trinnprofil
# ------------------------------------------------------------

# Randbetingelser (Dirichlet)
def u_left(t):
    """Venstre randverdi u(a,t)."""
    return -1.0

def u_right(t):
    """Høyre randverdi u(b,t)."""
    return 0.0


# ------------------------------------------------------------
# Initialbetingelse:
# u(x,0) = -0.5 * (1 - sign(x))
#
# Merk:
#  - for x < 0: sign(x) = -1  => u = -1
#  - for x > 0: sign(x) =  1  => u =  0
# Altså: u = -1 til venstre, og u = 0 til høyre.
# ------------------------------------------------------------
u0 = -0.5 * (1.0 - np.sign(x_grid))

# Lagrer løsningen for alle tider
u = np.zeros((t_grid.size, x_grid.size))
u[0, :] = u0

# CFL-sjekk 
cfl = (dt / dx) * np.max(np.abs(u0))
print("max|u0| =", np.max(np.abs(u0)))
print("CFL ~ (dt/dx)*max|u0| =", cfl)

# Tidsløkken (Lax–Friedrichs)
for n_step in range(1, t_grid.size):
    t_now = t_grid[n_step - 1]
    u[n_step, :] = lax_friedrichs_step(
        flux_burgers, u[n_step - 1, :], dx, dt, t_now, u_left, u_right
    )

# Diagnose: sjekk at løsningen endrer seg
print("Maks endring fra t0 til t1:", np.max(np.abs(u[1, :] - u[0, :])))

# ------------------------------------------------------------
# Animasjon 
# ------------------------------------------------------------
fig, ax = plt.subplots(figsize=(6, 4))

ax.set_xlim(x_grid[0], x_grid[-1])
ax.set_ylim(np.min(u), np.max(u))
ax.set_xlabel("x")
ax.set_ylabel("u(x,t)")
ax.set_title("Burgers' ligning: motsatt trinnprofil")

# Rød stiplet: startprofil
ax.plot(x_grid, u0, color="red", linestyle="--", label="u(x,0) (startprofil)")

# Blå kurve: løsning som oppdateres
line, = ax.plot(x_grid, u[0, :], color="blue", label="u(x,t)")

ax.legend()

def animate(i):
    line.set_ydata(u[i, :])
    return line,

ani = animation.FuncAnimation(
    fig,
    animate,
    frames=t_grid.size,
    interval=20,
    blit=True
)

HTML(ani.to_jshtml())
plt.show()
```
