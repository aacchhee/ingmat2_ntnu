# Varmeligning, 2D (i rom)

Dette er en utvidelse av de siste kapitlene: vi bruker samme diskretisering som i Poissons ligning til å få en differensialligning

$$
\vec{u}_t = A\vec{u} - \vec{F}
$$

Den kan da løses med Eulers metode. Vi følger altså nøyaktig samme oppskrift som i kapittel 9, bortsett fra at $A$ og $\vec{F}$ denne gangen kommer fra 10 (istedenfor 8). 

## Eksempel

Her løser vi varmeligningen 
$$
u_t = u_{xx} + u_{yy}, \quad 0<x<1, 0<y<1, t>0
$$

med samme randbetingelse som forrige kapittel: $u(t,x,0)=u(t,0,y)=u(t,1,y)=0$, $u(t,x,1)=\sin(\pi x)$. I tillegg tar vi som initialbetingelse $u(0,x,y)=y$.

Vi starter på akkurat samme måte som for poissonlikningen. Koden under er som i kapittel 10.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# Siste kapittel: oppsett av 2D Poisson/Laplace-problem
#
# Vi ser på domenet Ω = (0,1)×(0,1) og bruker Dirichlet-randbetingelser.
# Vi diskretiserer med 5-punkts stencil og bygger operatoren med Kroneckerprodukt.
# ------------------------------------------------------------

# ------------------------------------------------------------
# 1) Gitter i x- og y-retning (inkl. randpunkter)
# ------------------------------------------------------------
m = 20                      # antall INDRE punkter i x-retning
n = 20                      # antall INDRE punkter i y-retning

x = np.linspace(0, 1, m + 2)
y = np.linspace(0, 1, n + 2)

h = x[1] - x[0]             # dx
k = y[1] - y[0]             # dy

x_in = x[1:-1]              # indre punkter (m stk)
y_in = y[1:-1]              # indre punkter (n stk)

print(f"dx = {h:.4f}, dy = {k:.4f}")

# ------------------------------------------------------------
# 2) 2D-Laplace-operator L (størrelse (m*n)×(m*n))
#    L = kron(Lx, I) + kron(I, Ly)
# ------------------------------------------------------------

Lx = (1 / h**2) * (
    np.diag((m - 1) * [1], -1) +
    np.diag(m * [-2], 0) +
    np.diag((m - 1) * [1], 1)
)
Ix = np.eye(m)

Ly = (1 / k**2) * (
    np.diag((n - 1) * [1], -1) +
    np.diag(n * [-2], 0) +
    np.diag((n - 1) * [1], 1)
)
Iy = np.eye(n)

L = np.kron(Lx, Iy) + np.kron(Ix, Ly)

print("Størrelse på L:", L.shape)

# ------------------------------------------------------------
# 3) Randbetingelser (Dirichlet)
#
#   y = 0: u(x,0) = f1(x)
#   y = 1: u(x,1) = f2(x)
#   x = 0: u(0,y) = f3(y)
#   x = 1: u(1,y) = f4(y)
# ------------------------------------------------------------

def f1(x):
    """u(x,0) (bunnrand)."""
    return 0 * x

def f2(x):
    """u(x,1) (topprand)."""
    return np.sin(np.pi * x)

def f3(y):
    """u(0,y) (venstre rand)."""
    return 0 * y

def f4(y):
    """u(1,y) (høyre rand)."""
    return 0 * y

# ------------------------------------------------------------
# 4) Bygg høyresiden F fra randbetingelsene
#
# Randbidraget kommer fra at naboverdier utenfor det indre området
# erstattes av kjente randverdier og flyttes over til høyresiden.
# ------------------------------------------------------------

# "Plukketøy" for første/siste indre indeks i hver retning
Zm_l = np.zeros(m); Zm_l[0]  = -1 / h**2   # venstre side (x=0)
Zm_r = np.zeros(m); Zm_r[-1] = -1 / h**2   # høyre side (x=1)
Zn_l = np.zeros(n); Zn_l[0]  = -1 / k**2   # bunn (y=0)
Zn_r = np.zeros(n); Zn_r[-1] = -1 / k**2   # topp (y=1)

# Randbidrag samlet i én vektor (lengde m*n)
F = (
    np.kron(f1(x_in), Zn_l) +   # y=0
    np.kron(f2(x_in), Zn_r) +   # y=1
    np.kron(Zm_l, f3(y_in)) +   # x=0
    np.kron(Zm_r, f4(y_in))     # x=1
)

print("Størrelse på F:", F.shape)

# ------------------------------------------------------------
# 5) Liten sjekk: plott randfunksjonene i x-retning
# ------------------------------------------------------------
plt.figure(figsize=(6, 4))
plt.plot(x_in, f1(x_in), "--", label="u(x,0)")
plt.plot(x_in, f2(x_in), "-",  label="u(x,1)")
plt.xlabel("x")
plt.ylabel("randverdi")
plt.title("Randbetingelser på y=0 og y=1")
plt.legend()
plt.show()
```

### Løsning med Eulers metode

Nå har vi fått ligningen

$$
\vec{u}_t = A\vec{u} - \vec{F},
$$

som kan løses med Eulers metode:

$$
\vec{u}_{n+1} = \vec{u}_n + h\big( A\vec{u}_n - \vec{F} \big)
$$

med tilstrekkelig små tidssteg $t_n = nk$. Alternativt kan vi bruke baklengs Euler

$$
\vec{u}_{n+1} = \vec{u}_n + h\big( A\vec{u}_{n+1} - \vec{F} \big),
$$

som resulterer i et lineært system

$$
(I - hA) \vec{u}_{n+1} = \vec{u}_n - h\vec{F}.
$$

Vi viser løsningen med (forlengs) Euler under:


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# Forlengs Euler for ODE-systemet u'(t) = g(u,t)
#
# Vi bruker denne etter romdiskretisering av et 2D-problem.
# Da blir u(t) en lang vektor med lengde m*n (indre punkter).
# ------------------------------------------------------------
def euler(g, u0, t0, t1, N):
    """
    Løser ODE-systemet u' = g(u,t) med forlengs Euler.

    Parametre:
      g  : høyreside g(u,t)
      u0 : initialtilstand (vektor)
      t0 : starttid
      t1 : sluttid
      N  : antall tidspunkter (inkl. start)

    Returnerer:
      u : løsning (N x dim)
      t : tidsgitter (N)
    """
    t = np.linspace(t0, t1, N)
    dt = t[1] - t[0]

    u = np.zeros((N, u0.size))
    u[0, :] = u0

    for i in range(N - 1):
        u[i + 1, :] = u[i, :] + dt * g(u[i, :], t[i])

    return u, t


# ------------------------------------------------------------
# Høyresiden i ODE-systemet
# Etter romdiskretisering får vi (typisk):
#   u'(t) = L u(t) - F
# ------------------------------------------------------------
def g(u, t):
    return L @ u - F


# ------------------------------------------------------------
# Rutenett for indre punkter (samme som tidligere)
# indexing='ij' gir:
#   X[i,j] = x_in[i],  Y[i,j] = y_in[j]
# ------------------------------------------------------------
x_in = x[1:-1]
y_in = y[1:-1]
X, Y = np.meshgrid(x_in, y_in, indexing="ij")

# ------------------------------------------------------------
# Initialtilstand u(x,y,0)
# Her velger vi u(x,y,0) = y (altså en "plan" som øker oppover).
# ------------------------------------------------------------
U0 = Y

# Vektorisering: viktig at rekkefølgen stemmer med L og F
u0 = np.reshape(U0, m * n)

print("Dimensjon på u0:", u0.shape)

# ------------------------------------------------------------
# Løs ODE-systemet i tid
# Vi trenger mange tidssteg fordi forlengs Euler har streng stabilitet.
# ------------------------------------------------------------
u, t = euler(g, u0, 0.0, 0.5, 10000)

print("dt =", t[1] - t[0])
print("Størrelse på u-matrisen:", u.shape)

# ------------------------------------------------------------
# Sjekk-plott: initialtilstanden (2D) med imshow
# ------------------------------------------------------------
plt.figure(figsize=(6, 4))
plt.imshow(U0.T, origin="lower", aspect="auto",
           extent=[x_in[0], x_in[-1], y_in[0], y_in[-1]])
plt.colorbar(label="u(x,y,0)")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Initialtilstand u(x,y,0) = y (på indre punkter)")
plt.show()
```

Vi plotter løsningene. 

Prøv med ulike antall tidssteg. Når antall tidssteg blir mange, nærmer vi oss likevektstilstanden som er løsningen vi kjenner fra kap 10.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# 3D-visualisering av løsningen ved et gitt tidspunkt
#
# Vi har løst ODE-systemet u'(t) = L u(t) - F med forlengs Euler.
# Her ser vi på løsningen etter et bestemt antall tidssteg.
# ------------------------------------------------------------

# Velg hvilket tidssteg vi vil visualisere
step = 500

print(f"Visualiserer løsning ved tidssteg {step}, t = {t[step]:.4f}")

# Reshape fra vektor til 2D-rutenett (indre punkter)
Z = np.reshape(u[step, :], (m, n))

# ------------------------------------------------------------
# 3D-plott av løsningen
# ------------------------------------------------------------
fig, ax = plt.subplots(
    subplot_kw={"projection": "3d"},
    figsize=(10, 8)
)

ax.plot_surface(X, Y, Z, cmap="viridis")

# Samme romlige skala som tidligere figurer
ax.set_xlim(x[1], x[-2])
ax.set_ylim(y[1], y[-2])
ax.set_zlim(np.min(Z), np.max(Z))

ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("u(x,y,t)")
ax.set_title(f"Løsning etter {step} tidssteg")

plt.show()
```

Figuren viser hvordan løsningen har utviklet seg etter et gitt antall tidssteg. Ved å sammenligne slike figurer for ulike tider kan vi få en intuitiv forståelse av den tidsavhengige dynamikken i systemet.

## Farger og animasjoner

Når det er varmen som plottes, er det ofte bedre å vise løsningen ved hjelp av farger.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

plt.close("all")

# ------------------------------------------------------------
# Animasjon av 2D-løsningen u(x,y,t) som fargekart
#
# Forutsetter at du allerede har:
#   - u : løsning fra Euler (form: (t.size, m*n))
#   - x, y : gitter (inkl. randpunkter)
#   - m, n : antall indre punkter i hver retning
#
# Vi bruker samme animasjons-stil som tidligere:
#   HTML(ani.to_jshtml()); plt.show()
# ------------------------------------------------------------

# Hvor mange frames vil vi vise?
# Vi tar et hopp på 'stride' tidssteg mellom hver frame for å få en raskere animasjon.
stride = 100
n_frames = 90  # som i originalkoden

# Vi lager en liste med faktiske tidindekser vi vil bruke (sikrer at vi ikke går utenfor)
frame_idx = [i * stride for i in range(n_frames) if i * stride < u.shape[0]]

# ------------------------------------------------------------
# Forbered "fargeskala" (samme skala i alle frames gir roligere animasjon)
# ------------------------------------------------------------
# Vi bruker de frame-verdiene vi faktisk skal vise når vi bestemmer min/max.
U_frames = np.array([u[j, :] for j in frame_idx])
vmin = np.min(U_frames)
vmax = np.max(U_frames)

# ------------------------------------------------------------
# Sett opp figur
# ------------------------------------------------------------
fig, ax = plt.subplots(figsize=(8, 6))

# Første frame som startbilde
Z0 = np.reshape(u[frame_idx[0], :], (m, n))

im = ax.imshow(
    -Z0.T,                 # .T for å få "riktig" orientering i imshow
    origin="lower",
    cmap="RdBu",
    vmin=-vmax, vmax=-vmin  # symmetrisk skala rundt 0 (nyttig for RdBu)
)

# Akse-etiketter (indre gitterpunkter)
ax.set_title("Tidsutvikling av u(x,y,t) (fargekart)")
ax.set_xlabel("x-indeks (indre punkter)")
ax.set_ylabel("y-indeks (indre punkter)")

# Fargebar gjør det lettere å tolke verdier
plt.colorbar(im, ax=ax, label="u-verdi")

# ------------------------------------------------------------
# Oppdateringsfunksjon (mer minnevennlig enn å lagre 90 bilder i en liste)
# ------------------------------------------------------------
def animate(frame_number):
    j = frame_idx[frame_number]
    Z = np.reshape(u[j, :], (m, n))
    im.set_data((-Z).T)
    ax.set_title(f"Tidsutvikling av u(x,y,t)  (t ≈ {j} tidssteg)")
    return (im,)

# ------------------------------------------------------------
# Lag animasjonen
# ------------------------------------------------------------
ani = animation.FuncAnimation(
    fig,
    animate,
    frames=len(frame_idx),
    interval=50,
    blit=True
)

HTML(ani.to_jshtml())
plt.show()
```
