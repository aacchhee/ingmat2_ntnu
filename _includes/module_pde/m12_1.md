# Differensiallikninger i 2D

Her skal vi se på hvordan man håndterer:

1. Poissonligning i 2D
2. Varmeligning i (2+1)D
3. 2D bevaringslover og bølgeligning

Med (2+1)D mener vi to dimensjoner i rom, og en i tid, dvs $u=u(x,y,t)$.

## 1. Poissonligning

Situasjon er ganske lik i to dimensjoner:

$$
u_{xx}(x,y) + u_{yy}(x,y) = f(x,y)
$$

De partiellderiverte tilnærmes med

$$
u_{xx}(x,y) \approx \frac{u(x+h,y)-2u(x,y) +u(x-h,y)}{h^2} 
$$
$$
u_{yy}(x,y) \approx \frac{u(x,y+k)-2u(x,y) +u(x,y-k)}{k^2} 
$$

Vi tar $h,k$ som konstanter, og $u_{m,n}=u(hm,kn)$, og ender opp med et lineært system:

$$
\frac{1}{h^2} \big( u_{m+1,n} + u_{m-1,n} \big) + 
\frac{1}{k^2} \big( u_{m,n+1} + u_{m,n-1} \big) -
\left( \frac{2}{h^2} + \frac{2}{k^2} \right)
u_{n,m} = f(mh,nk),
$$

Det kan skrives i matriseform hvis vi skriver $u = (u_{1,1}, u_{2,1},\ldots,u_{m,1},u_{1,2},\ldots)$. Den største utfordringen i forhold til den endimensjonale ligningen er hvordan man håndtere $u$ som en vektor, da det ville vært lettere å ha den som en todimensjonal array.

### a) Vektorisering og "reshape"

Den naturlige måte å lagre våre ukjente er i en array, $u_{i,j} = u(x_i, y_j)$.

Men målet vårt er å gjøre om poissonligningen til et lineært system

$$
L\vec{u} = \vec{F}
$$

som krever at vi gjør om $u$ til en vektor, for eksempel $u = (u_{1,1}, u_{2,1},\ldots,u_{m,1},u_{1,2},\ldots)$. Det kalles for en *vektorisering* (https://en.wikipedia.org/wiki/Vectorization_(mathematics))

Vi kan håndtere det gjennom bruk av "reshape" i numpy. 

### Oppgave: 

Øv på å bruke reshape helt til du har forstått hvordan den fungerer.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# Introduksjon til 2D-arrays i NumPy
# ------------------------------------------------------------
# I 2D-problemer (for eksempel PDE-er i planet),
# vil løsningen ofte lagres som en matrise.
# ------------------------------------------------------------

# Eksempel på en 2D-array (matrise)
u = np.array([
    [1, 2, 3, 4],
    [5, 6, 7, 8]
])

# Antall rader (y-retning) og kolonner (x-retning)
m = u.shape[0]
n = u.shape[1]

print("Antall rader m =", m)
print("Antall kolonner n =", n)

# ------------------------------------------------------------
# Reshape: matrise <-> vektor
# ------------------------------------------------------------
# Ofte må vi løse lineære systemer A u = f,
# der u må være en vektor.
# Da flater vi ut matrisen til én lang vektor.
# ------------------------------------------------------------

# Gjør om fra matrise til vektor (radvis)
u_vec = np.reshape(u, m * n)

print("u som vektor:")
print(u_vec)

# Og tilbake til matrise igjen
u_mat = np.reshape(u_vec, (m, n))

print("u tilbake som matrise:")
print(u_mat)

# ------------------------------------------------------------
# Enkel visualisering
# ------------------------------------------------------------
# Vi plotter første rad i matrisen som et 1D-plott
plt.figure(figsize=(6, 4))
plt.plot(u_mat[0, :], marker="o")
plt.xlabel("kolonneindeks")
plt.ylabel("verdi")
plt.title("Første rad av 2D-arrayen u")
plt.show()
```

reshape endrer bare hvordan dataene tolkes, ikke selve tallene.
Dette gjør det mulig å gå sømløst mellom 2D-representasjon (for visualisering) og 1D-representasjon (for lineære ligningssystemer).

### b) Vi lager matrisen 1: for-løkker

Utfordringen sammenlignet med 6_1 er å sette sammen ligningene

$$
\frac{1}{h^2} \big( u_{i+1,j} + u_{i-1,j} \big) + 
\frac{1}{k^2} \big( u_{i,j+1} + u_{i,j-1} \big) -
\left( \frac{2}{h^2} + \frac{2}{k^2} \right)
u_{i,j} = f(ih,jk),
$$

til et system

$$
L\vec{u} = \vec{F}
$$

ved hjelp av vektorisering. Vi skal se et smart triks i 1c) under, men vi kan få det til med en for-løkke også.

La oss tenke på vektoriseringen $u = (u_{1,1}, u_{2,1}, \ldots)$. Vi antar at dimensjonen på $u$ er $m \times n$. Da ser vi at etter vektorisering blir

$$
u_{i,j} = u_{i + mj}
$$

Vi har altså 

$$
\frac{1}{h^2} \big( u_{i+1 + mj} + u_{i-1+mj} \big) + 
\frac{1}{k^2} \big( u_{i+m(j+1)} + u_{i+m(j-1)} \big) -
\left( \frac{2}{h^2} + \frac{2}{k^2} \right)
u_{i+mj} = f(ih,jk),
$$

Som kan skrives om til

$$
\frac{1}{h^2} \big( u_{(i+mj)+1} + u_{(i+mj)-1} \big) + 
\frac{1}{k^2} \big( u_{(i+mj)+m)} + u_{(i+mj)-m)} \big) -
\left( \frac{2}{h^2} + \frac{2}{k^2} \right)
u_{i+mj} = f(ih,jk),
$$

Hvis vi skriver $p=i+mj$, har vi

$$
\frac{1}{h^2} \big( u_{p+1} + u_{p-1} \big) + 
\frac{1}{k^2} \big( u_{(p+m)} + u_{(p-m)} \big) -
\left( \frac{2}{h^2} + \frac{2}{k^2} \right)
u_{p} = f(p),
$$

hvor vi får $f(p)$ gjennom vektorisering av $f(ih,jk)$.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# 2D-gitter på [0,1]x[0,1] og 2D-Laplace-operator (for hånd)
#
# Vi har m indre punkter i x-retning og n indre punkter i y-retning.
# Totalt blir det m*n ukjente, og Laplace-operatoren blir en (m*n)x(m*n)-matrise.
# ------------------------------------------------------------

# Antall INDRE punkter i x- og y-retning
m = 3
n = 3

# Gitterpunkter inkludert randpunkter (0 og 1)
x = np.linspace(0, 1, m + 2)
y = np.linspace(0, 1, n + 2)

# Steglengder
h = x[1] - x[0]   # dx
k = y[1] - y[0]   # dy

print("dx =", h, "dy =", k)

# ------------------------------------------------------------
# Indeksering:
# Vi nummererer de indre punktene (i,j) med én indeks p:
#
#   i = 0,1,...,m-1   (x-retning, indre punkter)
#   j = 0,1,...,n-1   (y-retning, indre punkter)
#
#   p = i + m*j   (radvis/kolonnevis flating)
#
# Dermed:
#   høyre nabo:  (i+1,j) -> p+1
#   venstre nabo:(i-1,j) -> p-1
#   opp nabo:    (i,j+1) -> p+m
#   ned nabo:    (i,j-1) -> p-m
# ------------------------------------------------------------

N = m * n  # totalt antall ukjente
L_for = np.zeros((N, N))

for p in range(N):
    i = p % m      # x-indeks (indre)
    j = p // m     # y-indeks (indre)

    # Kobling i x-retning (høyre/venstre)
    if i < m - 1:
        L_for[p, p + 1] = 1 / h**2
    if i > 0:
        L_for[p, p - 1] = 1 / h**2

    # Kobling i y-retning (opp/ned)
    if j < n - 1:
        L_for[p, p + m] = 1 / k**2
    if j > 0:
        L_for[p, p - m] = 1 / k**2

    # Diagonalledd: -2/dx^2 - 2/dy^2 (standard 5-punkts stencil)
    L_for[p, p] = -2 / h**2 - 2 / k**2

print("2D-Laplace-matrise (for hånd):")
print(L_for)

# ------------------------------------------------------------
# Visualisering av selve 2D-gitteret (inkl. randpunkter)
# ------------------------------------------------------------
X, Y = np.meshgrid(x, y, indexing="xy")

plt.figure(figsize=(5, 5))
plt.plot(X, Y, "k.", markersize=6)   # alle punkter
plt.title("2D-gitter på [0,1]×[0,1] (inkl. randpunkter)")
plt.xlabel("x")
plt.ylabel("y")
plt.axis("equal")
plt.show()
```

### c) Vi lager matrisen 2: Kroneckerproduktet

Det er ganske vrient å sette opp matrisen med for-løkker, men et nyttig triks er å bruke *Kroneckerproduktet* (https://en.wikipedia.org/wiki/Kronecker_product). Det er et slags produkt av matriser, skrevet som $\otimes$, som er nyttig i forbindelse med vektorisering. Merk at produktet er helt forskjellig fra matriseproduktet du kan fra før.

Her viser det seg at matrisen $L$ vi ønsker oss er lik

$$
L = L_m \otimes I_n + I_m \otimes L_n,
$$

hvor $L_m, L_n$ tilsvarer matrisene for henholdsvis $u_{xx}, u_{yy}$ (fra de en-dimensjonale tilnærmingene til poissonligningen), og $I_m, I_n$ er idetitetsmatrisene med størrelse $m,n$.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# 2D-Laplace-operator ved hjelp av Kroneckerprodukt
#
# På et rektangel [0,1]×[0,1] med Dirichlet-randbetingelser
# diskretiserer vi Laplace-operatoren med 5-punkts stencil:
#
#   Δu ≈ (u_{i+1,j} - 2u_{i,j} + u_{i-1,j})/dx^2
#      + (u_{i,j+1} - 2u_{i,j} + u_{i,j-1})/dy^2
#
# Når vi flater ut u(i,j) til en vektor, kan vi skrive 2D-operatoren som:
#
#   L_2D = kron(Lx, I_y) + kron(I_x, Ly)
# ------------------------------------------------------------

# Antall INDRE punkter i x- og y-retning
m = 20
n = 20

# Gitter (inkl. randpunkter)
x = np.linspace(0, 1, m + 2)
y = np.linspace(0, 1, n + 2)

dx = x[1] - x[0]
dy = y[1] - y[0]

print(f"dx = {dx:.4f}, dy = {dy:.4f}")

# ------------------------------------------------------------
# 1D Laplace-matriser på indre punkter
# (tridiagonal: -2 på diagonal, 1 på nabo-diagonaler)
# ------------------------------------------------------------

Lx = (1 / dx**2) * (
    np.diag((m - 1) * [1], -1) +
    np.diag(m * [-2], 0) +
    np.diag((m - 1) * [1], 1)
)
Ix = np.eye(m)

Ly = (1 / dy**2) * (
    np.diag((n - 1) * [1], -1) +
    np.diag(n * [-2], 0) +
    np.diag((n - 1) * [1], 1)
)
Iy = np.eye(n)

# ------------------------------------------------------------
# 2D Laplace-operator (på formen (m*n)×(m*n))
# ------------------------------------------------------------
L = np.kron(Lx, Iy) + np.kron(Ix, Ly)

print("Størrelse på L:", L.shape)

# ------------------------------------------------------------
# Visualisering: strukturen til matrisen
# (Spy-plot viser hvor de ikke-null elementene ligger)
# ------------------------------------------------------------
plt.figure(figsize=(6, 4))
plt.spy(L, markersize=1)
plt.title("Struktur (sparsity) til 2D-Laplace-matrisen")
plt.xlabel("kolonneindeks")
plt.ylabel("radindeks")
plt.show()
```

Kroneckerformen gjør det lett å bygge 2D-operatoren fra to 1D-operatorer, og den avslører samtidig at matrisen er svært sparsom (få ikke-null elementer). Dette blir viktig når vi skal løse store systemer effektivt.

## 2. Dirichletbetingelser

Randbetingelsene vi velger påvirker både matrise $L$ og vektoren $\vec{F}$, slik vi så for én dimensjon i rom.

Vi begynner med dirichletbetingelser, hvor $u$ oppgis på randen.

Siden vi jobber med $0<x<1$ og $0<y<1$, har randen fire deler:

1. $y=0$

Her setter vi $u(x,0) = f_1(x)$.

2. $y=1$

Her setter vi $u(x,1) = f_2(x)$.

3. $x=0$

Her setter vi $u(0,y) = f_3(y)$.

4. $x=1$

Her setter vi $u(1,y) = f_4(y)$.

Alle funksjonene $f_i$ antas oppgitt i problemet. Husk at vi ønsker å løse et lineært system med ligninger

$$
\frac{1}{h^2} \big( u_{i+1,j} + u_{i-1,j} \big) + 
\frac{1}{k^2} \big( u_{i,j+1} + u_{i,j-1} \big) -
\left( \frac{2}{h^2} + \frac{2}{k^2} \right)
u_{n,m} = f(ih,jk),
$$

Fremgangsmåte er som for én dimensjon. Alle $u_{i,j}$ i disse ligningene som havner på randen sendes over til den høyre siden. For eksempel, hvis vi tar $m=n=1$, har vi

$$
\frac{1}{h^2} u_{2,1} + \frac{1}{k^2} u_{1,2}  - \left( \frac{2}{h^2} + \frac{2}{k^2} \right) u_{1,1} = f(h,k) - \frac{1}{h^2} u_{0,1} - \frac{1}{k^2} u_{1,0}
$$

Vi kan da sette inn $u_{0,1} = u(0,k) = f_3(k)$ og $u_{1,0} = u(h,0) = f_1(h)$ og få

$$
\frac{1}{h^2} u_{2,1} + \frac{1}{k^2} u_{1,2}  - \left( \frac{2}{h^2} + \frac{2}{k^2} \right) u_{1,1} = f(h,k) - \frac{1}{h^2} f_3(k) - \frac{1}{k^2} f_1(h)
$$

Konklusjonen er at vi ikke trenger å gjøre noe med matrisa $L$, men at vi legger til ekstraleddene som kommer fra $f_i$ på høyresiden.

### Eksempel 1.

Her er koden som løser randverdiproblem med $f(x)=0$ og $u(x,0)=u(0,y)=u(1,y)=0$, $u(x,1)=\sin(\pi x)$.

Her kan vi sammenligne med en eksakt løsningen (som kan finnes med separasjon av variable) lik

$$
u(x,y) = \frac{\sin(\pi x)\sinh(\pi y)}{\sinh(\pi)}
$$

Koden under bruker Kroneckerproduktet til å legge til randbetingelsene på riktig plass.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# Randbetingelser i 2D (Dirichlet) og bidrag til høyresiden F
#
# Vi løser typisk Poisson-problemet på (0,1)×(0,1):
#   -Δu = f
#
# Ukjente er kun i de indre punktene:
#   x[1:-1] og y[1:-1]
#
# Randverdier u = g gis på randen:
#   y = 0   (bunn):   u(x,0) = f1(x)
#   y = 1   (topp):   u(x,1) = f2(x)
#   x = 0   (venstre):u(0,y) = f3(y)
#   x = 1   (høyre):  u(1,y) = f4(y)
#
# Når vi diskretiserer Laplace-operatoren, kommer randverdiene inn i
# ligningene for punktene nær randen, og flyttes derfor over til høyresiden F.
# ------------------------------------------------------------

# --- "kantvektorer" som plukker ut første og siste indre indeks ---
# Disse gir koeffisientene -1/dx^2 eller -1/dy^2 i riktig posisjon
Zm_l = np.zeros(m)     # venstre kolonne (første indre x-indeks)
Zm_l[0] = -1 / (h**2)

Zm_r = np.zeros(m)     # høyre kolonne (siste indre x-indeks)
Zm_r[-1] = -1 / (h**2)

Zn_l = np.zeros(n)     # nederste rad (første indre y-indeks)
Zn_l[0] = -1 / (k**2)

Zn_r = np.zeros(n)     # øverste rad (siste indre y-indeks)
Zn_r[-1] = -1 / (k**2)

# ------------------------------------------------------------
# Dirichlet-randbetingelser (velg gjerne andre funksjoner)
# ------------------------------------------------------------
def f1(x):
    """u(x,0) (bunnrand)"""
    return 0 * x

def f2(x):
    """u(x,1) (topprand)"""
    return np.sin(np.pi * x)

def f3(y):
    """u(0,y) (venstre rand)"""
    return 0 * y

def f4(y):
    """u(1,y) (høyre rand)"""
    return 0 * y


# ------------------------------------------------------------
# Bygg høyresiden F fra randbetingelsene
#
# Vi bruker samme vektoriseringsidé som ved Kroneckerprodukt:
# u(i,j) flates ut til én vektor i en bestemt rekkefølge.
#
# Her bygger vi kun randbidraget. (Eventuelt volumledd f(x,y) legges til senere.)
# ------------------------------------------------------------

x_in = x[1:-1]  # indre x-punkter (m stk)
y_in = y[1:-1]  # indre y-punkter (n stk)

F = (
    np.kron(f1(x_in), Zn_l) +   # bunnrand y=0
    np.kron(f2(x_in), Zn_r) +   # topprand y=1
    np.kron(Zm_l, f3(y_in)) +   # venstre rand x=0
    np.kron(Zm_r, f4(y_in))     # høyre rand x=1
)

print("Størrelse på F:", F.shape)

# ------------------------------------------------------------
# (Liten sanity check) Plott randfunksjonene i x-retning
# ------------------------------------------------------------
plt.figure(figsize=(6, 4))
plt.plot(x_in, f1(x_in), "--", label="u(x,0) = f1(x)")
plt.plot(x_in, f2(x_in), "-",  label="u(x,1) = f2(x)")
plt.xlabel("x")
plt.ylabel("randverdi")
plt.title("Randbetingelser på y=0 og y=1")
plt.legend()
plt.show()
```


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# Legg til volumledd (kildeledd) f(x,y) i høyresiden
#
# For eksempel for Poisson:
#   -Δu = f(x,y)
#
# I forrige kode bygget vi F fra randbetingelsene.
# Nå legger vi til bidraget fra f(x,y) evaluert i indre punkter.
# ------------------------------------------------------------

# Indre punkter
x_in = x[1:-1]   # m punkter
y_in = y[1:-1]   # n punkter

# Lager rutenett av indre punkter
# indexing="ij" betyr:
#   X[i,j] = x_in[i]  og  Y[i,j] = y_in[j]
# (dette passer med indeksering u(i,j) der i går i x-retning og j i y-retning)
X, Y = np.meshgrid(x_in, y_in, indexing="ij")

# ------------------------------------------------------------
# Kildeledd f(x,y)
# Her bruker vi f=0 som standard (bytt gjerne til noe annet)
# ------------------------------------------------------------
def f_source(x, y):
    """Kildeledd f(x,y) i -Δu = f."""
    return 0 * x * y

# Funksjonsverdier på rutenettet (m x n matrise)
Z = f_source(X, Y)

# Vektoriser (må samsvare med samme rekkefølge som vi bruker ellers)
G = np.reshape(Z, m * n)

# Legg volumleddet til høyresiden (som allerede inneholder randbidrag)
F = F + G

print("Størrelse på G:", G.shape)
print("Størrelse på F:", F.shape)

# ------------------------------------------------------------
# Visualisering av f(x,y) på indre punkter (valgfritt, men nyttig)
# ------------------------------------------------------------
plt.figure(figsize=(5, 4))
plt.imshow(Z.T, origin="lower", aspect="auto",
           extent=[x_in[0], x_in[-1], y_in[0], y_in[-1]])
plt.colorbar(label="f(x,y)")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Kildeledd f(x,y) på indre gitterpunkter")
plt.show()
```

Det er viktig at vektoriseringen av $f(x,y)$ skjer i samme rekkefølge som vi brukte da vi bygget 2D-Laplace-operatoren med Kroneckerprodukt. Hvis ikke kan vi få riktige tall, men plassert på feil steder i vektoren.

### Løsning

Nå er vi klar til å løse systemet

$$
L\vec{u} = \vec{F}
$$

For å plotte resultatet bruker vi reshape til å få tilbake $U(x_i,y_j)$ som en array.

**Obs**: koden over bruker $(x_i,y_j)$, ikke $(x_j,y_i)$, se diskusjonen i 6_1, "Advarsel: arrayer, rutenett og meshgrid".


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import numpy.linalg as la

plt.close("all")

# ------------------------------------------------------------
# Løs det lineære systemet L u = F
# ------------------------------------------------------------

u = la.solve(L, F)
U = np.reshape(u, (m, n))

# ------------------------------------------------------------
# 3D-visualisering (samme skala/stil som tidligere)
# ------------------------------------------------------------

fig, ax = plt.subplots(
    subplot_kw={"projection": "3d"},
    figsize=(10, 8)
)

ax.plot_surface(X, Y, U, cmap="viridis")

# Samme romlige skala som gitteret
ax.set_xlim(x[1], x[-2])
ax.set_ylim(y[1], y[-2])

# Z-skala basert på løsningen (gir stabil visning)
ax.set_zlim(np.min(U), np.max(U))

ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("u(x,y)")
ax.set_title("Numerisk løsning av 2D Poisson-problem")

plt.show()
```

Den kan sammenlignes med den eksakte løsningen:


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# Analytisk løsning av 2D Laplace-problem
#
# Vi ser på Laplace-ligningen:
#   -Δu = 0   på (0,1)×(0,1)
#
# med randbetingelser:
#   u(x,0) = 0
#   u(x,1) = sin(πx)
#   u(0,y) = u(1,y) = 0
#
# Denne har den analytiske løsningen:
#   u(x,y) = sin(πx) * sinh(πy) / sinh(π)
# ------------------------------------------------------------

def u_exact(x, y):
    """Analytisk løsning u(x,y)."""
    return np.sin(np.pi * x) * np.sinh(np.pi * y) / np.sinh(np.pi)

# Evaluer analytisk løsning på samme indre rutenett som før
Z = u_exact(X, Y)

# ------------------------------------------------------------
# 3D-visualisering (samme stil/skala som numerisk løsning)
# ------------------------------------------------------------
fig, ax = plt.subplots(
    subplot_kw={"projection": "3d"},
    figsize=(10, 8)
)

ax.plot_surface(X, Y, Z, cmap="viridis")

ax.set_xlim(x[1], x[-2])
ax.set_ylim(y[1], y[-2])
ax.set_zlim(np.min(Z), np.max(Z))

ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("u(x,y)")
ax.set_title("Analytisk løsning av 2D Laplace-problem")

plt.show()
```

Ved å sammenligne den numeriske løsningen med den analytiske løsningen punkt for punkt, kan vi visualisere feilen som en egen flate. Dette gir et klart bilde av hvor i domenet diskretiseringen gir størst avvik.

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# Feilflate: |u_numerisk - u_analytisk|
#
# Forutsetter:
#   U : numerisk løsning på indre punkter (form m x n)
#   X, Y : rutenett for indre punkter
# ------------------------------------------------------------

# Analytisk løsning (samme som tidligere)
def u_exact(x, y):
    return np.sin(np.pi * x) * np.sinh(np.pi * y) / np.sinh(np.pi)

# Evaluer analytisk løsning på rutenettet
U_exact = u_exact(X, Y)

# Beregn punktvis absolutt feil
E = np.abs(U - U_exact)

print("Maksimal absolutt feil:", np.max(E))

# ------------------------------------------------------------
# 3D-visualisering av feilflaten
# ------------------------------------------------------------
fig, ax = plt.subplots(
    subplot_kw={"projection": "3d"},
    figsize=(10, 8)
)

ax.plot_surface(X, Y, E, cmap="inferno")

ax.set_xlim(x[1], x[-2])
ax.set_ylim(y[1], y[-2])
ax.set_zlim(0, np.max(E))

ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("absolutt feil")
ax.set_title("Feilflate |u_numerisk − u_analytisk|")

plt.show()
```

Figuren under oppsummerer hele den numeriske arbeidsflyten i 2D: fra den kontinuerlige differensialligningen, via diskretisering og lineært system, til numerisk løsning og visualisering.
```{pyodide-python}
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# Vertikal oppsummeringsfigur: numerisk arbeidsflyt i 2D
# ------------------------------------------------------------

fig, ax = plt.subplots(figsize=(6, 8))
ax.axis("off")

# Tekstbokser: (x, y, tekst)
boxes = [
    (0.5, 0.85, "PDE\n−Δu = f\npå Ω"),
    (0.5, 0.65, "Diskretisering\n(gitter + differanser)"),
    (0.5, 0.45, "Lineært system\nL u = F"),
    (0.5, 0.25, "Numerisk løsning\nu ≈ u(x,y)"),
    (0.5, 0.08, "Visualisering\n(2D / 3D / feilflate)")
]

# Tegn bokser
for x0, y0, text in boxes:
    ax.text(
        x0, y0, text,
        ha="center", va="center",
        bbox=dict(boxstyle="round,pad=0.5", fc="lightgray", ec="black"),
        fontsize=11
    )

# Tegn piler mellom boksene
arrowprops = dict(arrowstyle="->", lw=2)

for i in range(len(boxes) - 1):
    ax.annotate(
        "",
        xy=(boxes[i+1][0], boxes[i+1][1] + 0.06),
        xytext=(boxes[i][0], boxes[i][1] - 0.06),
        arrowprops=arrowprops
    )

ax.set_title(
    "Arbeidsflyt i numerisk løsning av 2D randverdiproblemer",
    fontsize=13
)

plt.show()

```