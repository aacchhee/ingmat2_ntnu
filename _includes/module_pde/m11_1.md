# Varmeligning

## 1. Varmeligning

Varmeligningen 

$$
u_t = c^2\bigtriangledown^2 u - f
$$

kan sees på som en tidsavhengig variant av poissonligningen. Legg merke til at en eventuell likeveksttilstand med $u_t=0$ faktisk løser poissonligningen.

### Randbetingelser

Randbetingelser i rom er altså tilsvarende poissonligningen - enten med dirichlet- eller neumannbetingelser.

I tillegg trenger vi en initialbetingelse, $u(\vec{x},0)=g(\vec{x})$.

Hvis vi betrakter problemet på hele $\mathbb{R}^n$ kan vi klare oss uten randbetingelser, men da er det problematisk å løse ligningen numerisk.

### Analytiske løsninger [ikke pensum]

Varmeligningen kan løses analytisk for visse geometrier. For eksempel har initialverdieproblemet

$$
u_t = c^2 u_{xx} + f(x,t), \quad u(x,0)=g(x)
$$

løsningen

$$
u(x,t) = \frac{1}{\sqrt{4\pi t}} \left( 
\int_{-\infty}^{\infty} e^{\frac{-(x-y)^2}{4t}} g(y) dy
+ \int_0^t
\int_{-\infty}^{\infty} e^{\frac{-(x-y)^2}{4(t-s)}} f(y,s) dy ds
\right)
$$

Lekkert! 

La oss se på hva som skjer når $f=0$ og 

$$
g(x) = \left\{
\begin{array}{c}
1 & |x|\leq 1 \\
0 & |x|>1
\end{array}
\right.
$$

Vi har
$$
u(x,t) = \frac{1}{\sqrt{4\pi t}} \int_{-1}^{1} e^{-\frac{(x-y)^2}{4t}} dy
$$

Men lenger kommer vi ikke, siden integralet ikke har noen analytisk løsning. Vi kan løse integralet numerisk, eller uttrykke det hjelp av *feilfunksjonen* gjennom substitusjon $z=-\frac{(x-y)^2}{4t}$.

Og verre blir det når vi har flere dimensjoner, særlig om geometrien på randen er komplisert.

**Oppgave**: 

La $x=2$. Forklar hvorfor integralet

$$
u(2,t) = \frac{1}{\sqrt{4\pi t}} \int_{-1}^{1} e^{-\frac{(2-y)^2}{4t}} dy
$$

er positiv (altså $u(2,t)>0$) for alle $t>0$, selv om $u(2,0)=0$.

Legg merke til at det betyr at verdiene $g(x),  -1<x<1$ påvirker $u(2,t)$ uansett hvor små $t$ er - informasjonsflyt i systemet går uendelig fort!

## 2. Fra poissonligning til varmeligning

Vi har sett hvordan en endimensjonal poissonligning

$$
u_{xx} + f(x) = 0
$$

med passende randbetingelser (f. eks., $u(0)=a, u(1)=b$)

kan tilnærmes med et lineært system

$$
L\vec{u} + \vec{F} = 0.
$$

Beskjeden er enkelt og greit at varmeligningen

$$
u_t = c^2 u_{xx} + f(x), \quad u(x,0)=g(x)
$$

tilnærmes med den tilsvarende *ordinære* differensialligningen

$$
\vec{u}_t = c^2 L\vec{u} + \vec{F}, \quad \vec{u}(0)=\vec{g},
$$

hvor $\vec{g}$ er en vektor med $g_i = g(x_i)$. 

### a) Koden gjenbrukes fra 8: dirichletbetingelser

Når vi skal løse varmeligningen numerisk, er det første steget altså å lage matrisen $L$ og vektoren $\vec{F}$ fra løsningen av poissonligningen. Vi gjenbruker koden fra kapittel 08. Vi ser først på dirichletbetingelser

$$
u(0,t)=a, \quad u(1,t)=b.
$$

Vektoren $\vec{F}$ er slik at $F_i = f(x_i)$, men vi må legge til 

$$
F_1 = f(x_0) - \frac{c^2 a}{h^2}, \quad F_{m+1} = f(x_{m+1}) - \frac{c^2 b}{h^2}
$$

på grunn av randbetingelsene, akkurat som for poissonligningen. Vi får en ekstra $c^2$ som kommer fra leddet $c^2 u_{xx}$.

Vi viser hvordan matrisene settes opp.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import numpy.linalg as la

plt.close("all")

# ------------------------------------------------------------
# Nytt kapittel: stasjonært problem av typen
#
#   -c^2 u''(x) = f(x),    x ∈ (0,1)
#   u(0) = a,   u(1) = b
#
# Dette kan sees som:
#  - Poisson-ligning (1D)
#  - stasjonær bølgeligning
# ------------------------------------------------------------

# Antall indre punkter
m = 20

# Romgitter (inkluderer randpunktene)
x = np.linspace(0, 1, m + 2)
h = x[1] - x[0]

# Parameter i ligningen (bølge-/materialparameter)
c = 1.0

# Randbetingelser
a = 0.0   # u(0)
b = 0.0   # u(1)

# ------------------------------------------------------------
# Diskret operator
#
# L ≈ -d^2/dx^2  (Laplace-operator i 1D)
# A = c^2 L
# ------------------------------------------------------------
L = (1 / h**2) * (
    np.diag((m - 1) * [1], -1) +
    np.diag(m * [-2], 0) +
    np.diag((m - 1) * [1], 1)
)

A = (c**2) * L

# ------------------------------------------------------------
# Høyreside f(x)
# I dette start-eksempelet tar vi f(x) = 0
# ------------------------------------------------------------
F = np.zeros(m)

# Bidrag fra randbetingelser
F[0]  -= (c**2) * a / h**2
F[-1] -= (c**2) * b / h**2

# ------------------------------------------------------------
# (Foreløpig) har vi satt opp ligningssystemet:
#
#   A U = F
#
# Selve løsningen av systemet kommer i neste kodeblokk.
# ------------------------------------------------------------

# Visualisering av romgitteret
plt.figure(figsize=(6, 2.5))
plt.plot(x, np.zeros_like(x), "o", markersize=6)
plt.plot(x[1:-1], np.zeros(m), "o", label="indre punkter")
plt.plot([x[0], x[-1]], [0, 0], "s", label="randpunkter")

plt.title("Romgitter på [0,1]")
plt.xlabel("x")
plt.yticks([])
plt.legend()
plt.show()
```

## 3. Løsning av ODE'en

Forlengs eulermetode for den nye ligningen er da

$$
\vec{u}_{i+1} = \vec{u}_i + k\big(L\vec{u}_i + \vec{F}\big) = (I+kL)\vec{u}_i + \vec{F},
$$

hvor $u_i = u(k\cdot i)$ er en diskretisering i tid med steglengde lik $k$. Den fungerer fint, *men bare hvis steglengdene oppfyller kravet* 

$$
c^2\frac{k}{h^2}<\frac{1}{2}.
$$

Resultatet kommer til å være helt meningsløst hvis dette kravet er ikke oppfylt, for $u_i$ vil da vanligvis gå raskt mot uendelig. I praksis er dette uheldig, siden $k$ da må være veldig liten i forhold til $h$, og vi trenger derfor ofte veldig mange tidssteg for å oppnå ønsket nøyaktighet. En mye bedre metode er baklengs Euler:

$$
\vec{u}_{i+1} = \vec{u}_i + k\big(A\vec{u}_{i+1} + \vec{F}\big),
$$

hvor vi kan finne $\vec{u}_{i+1}$ ved å løse det lineære systemet

$$
(I - kA)\vec{u}_{i+1} = \vec{u}_i + \vec{F}.
$$

Matrisen $I-kA$ er forøvrig konstant i tid, og vi trenger derfor å invertere den (eller bedre: finne Cholesky-faktoreringen) bare en gang. Denne metoden gir alltid fornuftige løsninger. 

Men merk at det er forlengs eulermetode som skal brukes i prosjektet!

### a) Eksempel 1: Dirichlet randbetingelser

Vi løser varmeligningen

$$
u_t = u_{xx}, \quad 0<x<1, \quad u(0,t)=0, \; u(1,t)=0, \quad u(x,0)=\sin(\pi x)
$$

med koden under.


```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

plt.close("all")

# ------------------------------------------------------------
# Semi-diskret PDE -> ODE-system
#
# Vi tar et 1D-problem på (0,1) med Dirichlet-randbetingelser,
# og diskretiserer i rom. Da får vi et ODE-system i tid:
#
#   u'(t) = A u(t) - F
#
# Dette ligner på varme-/diffusjonsligningen etter romdiskretisering.
# Her bruker vi forlengs Euler i tid (enkelt, men kan kreve små tidssteg).
# ------------------------------------------------------------

# --- Romdiskretisering (samme som over) ---
m = 20
x = np.linspace(0, 1, m + 2)
h = x[1] - x[0]

c = 1.0  # parameter i operatoren

# L ≈ -d^2/dx^2 på indre punkter
L = (1 / h**2) * (
    np.diag((m - 1) * [1], -1) +
    np.diag(m * [-2], 0) +
    np.diag((m - 1) * [1], 1)
)

A = (c**2) * L

# Randbetingelser u(0)=a, u(1)=b
a = 0.0
b = 0.0

# Høyreside (her: f(x)=0, men randbetingelser kan gi bidrag i F)
F = np.zeros(m)
F[0]  -= (c**2) * a / h**2
F[-1] -= (c**2) * b / h**2


# ------------------------------------------------------------
# Forlengs Euler: x_{n+1} = x_n + dt * g(x_n, t_n)
# ------------------------------------------------------------
def euler(g, x0, t0, t1, N):
    """
    Løser ODE-systemet x' = g(x,t) med forlengs Euler.

    Parametre:
      g  : høyreside g(x,t)
      x0 : initialtilstand (vektor)
      t0 : starttid
      t1 : sluttid
      N  : antall tidspunkter

    Returnerer:
      x : array med løsning (N x dim)
      t : tidsgitter (N)
    """
    t = np.linspace(t0, t1, N)
    dt = t[1] - t[0]

    xsol = np.zeros((N, x0.size))
    xsol[0, :] = x0

    for n in range(N - 1):
        xsol[n + 1, :] = xsol[n, :] + dt * g(xsol[n, :], t[n])

    return xsol, t


# Høyresiden til ODE-systemet: u'(t) = A u(t) - F
def g(u, t):
    return A @ u - F


# ------------------------------------------------------------
# Initialbetingelse (på indre punkter)
# Merk: vi bruker x[1:-1] fordi randpunktene er gitt av Dirichlet-betingelser.
# ------------------------------------------------------------
u0 = np.sin(np.pi * x[1:-1])

# Mange tidssteg fordi forlengs Euler kan være ustabil hvis dt er for stort
u, t = euler(g, u0, 0.0, 1.0, 1000)

print("dt =", t[1] - t[0])
print("Maksverdi ved start:", np.max(u[0, :]))
print("Maksverdi ved slutt:", np.max(u[-1, :]))

# ------------------------------------------------------------
# Plot: løsning ved ulike tider (ulike tidssteg)
# ------------------------------------------------------------
plt.figure(figsize=(6, 4))
plt.plot(x[1:-1], u[50, :],  label="t = t[50]")
plt.plot(x[1:-1], u[100, :], label="t = t[100]")
plt.plot(x[1:-1], u[200, :], label="t = t[200]")

plt.xlabel("x")
plt.ylabel("u(x,t)")
plt.title("Utvikling i tid med forlengs Euler (semi-diskret system)")
plt.legend()
plt.show()
```

Forlengs Euler er lett å implementere, men kan bli ustabil hvis tidssteget er for stort. I praksis betyr dette at vi må bruke mange små tidssteg.

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

plt.close("all")

# ------------------------------------------------------------
# Animasjon av løsningen u(x,t)
# Forutsetter at du allerede har kjørt koden som lager:
#   - x (med randpunkter)
#   - t (tidsgitter)
#   - u (løsningen i indre punkter), med form (t.size, m)
#
# Merk:
#  - u er definert kun på indre punkter, derfor bruker vi x[1:-1] på x-aksen.
# ------------------------------------------------------------

# Vi animerer bare første del av simuleringen, siden løsningen ofte nærmer seg 0 raskt
n_frames = t.size // 5

fig, ax = plt.subplots(figsize=(6, 4))

# Faste aksegrenser (gir roligere animasjon)
ax.set_xlim(x[1], x[-2])
ax.set_ylim(0.0, np.max(u))   # siden initialtilstanden er sin(pi x) >= 0 på (0,1)

ax.set_xlabel("x")
ax.set_ylabel("u(x,t)")
ax.set_title("Tidsutvikling (forlengs Euler)")

# Blå kurve: initialplott
line, = ax.plot(x[1:-1], u[0, :], color="blue", label="u(x,t)")
ax.legend()

def animate(i):
    line.set_ydata(u[i, :])
    return line,

# Animasjon (samme parametre/stil som i forrige kapittel)
ani = animation.FuncAnimation(
    fig,
    animate,
    frames=n_frames,
    interval=20,
    blit=True
)

# Vis animasjonen i Quarto / nettleser
HTML(ani.to_jshtml())
plt.show()
```
